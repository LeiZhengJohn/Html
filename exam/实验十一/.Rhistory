install.packages("car")
install.packages("car")
library(car)
vif(lm.step)
dir="D:/RFile/实验十一"
setwd(dir)
file="15生信成绩.txt"
scores<-read.table(file,head=T,sep="\t")
colnames(scores)
ncol(scores)
#[1] 25 =》24门课程
nrow(scores)
#[1] 30
#创建数据框
data<-data.frame(scores[,2:25])
colnames(data)<-paste("x",1:24, sep="")
rownames(data)<-scores[,1]
data #查看数据
View(scores)
library(psych)
corr.test(data)
install.packages("psych")
library(psych)
corr.test(data)
dir="D:/RFile/实验十一"
setwd(dir)
file="15生信成绩.txt"
scores<-read.table(file,head=T,sep="\t")
colnames(scores)
ncol(scores)
#[1] 25 =》24门课程
nrow(scores)
#[1] 30
#创建数据框
data<-data.frame(scores[,2:25])
colnames(data)<-paste("x",1:24, sep="")
rownames(data)<-scores[,1]
data #查看数据
library(psych)
corr.test(data)
#原数据：
png("boxplot1.png")
boxplot(data,las=2)
dev.off()
#数据中心化，使其均值变为零【原点】
data2<-scale(data, center=T,scale=F)
data2
png("lboxplot2.png")
boxplot(data2,las=2)
dev.off()
#数据围绕0附近波动，但是方差变异很大
#数据标准化，除以方差
data3<-scale(data, center=T, scale=T)
data3
png("boxplot3.png")
boxplot(data3,las=2)
dev.off()
mc<-cov(data3)
mc
#cor：逻辑变量，若为cor=T表示用样本的相关矩阵R作主成分分析，cor=F, 表示用样本的协方差矩阵s作为主成分分析
pca<-princomp(data,cor=T)
pca2<-princomp(data2,cor=T)
pca3<-princomp(data3,cor=T)
#以上几个结果相同，princomp自动进行上述中心化和标准化处理
pca
summary(pca)
pca[]#查看详细信息
pca$sdev #Standard deviation
pca$loadings #loading系数矩阵
pca$center #每一门课程均值=》数据中心化
pca$scale #每一门课程方差=》数据标准化
pca$scores #每个样本每个组分的得分
pca$loadings #查看loadins信息
pca$loadings[] #查看loadings全部数值
#计算得到各个样本主成分的数据=》等价于pca$scores
pca_data <- predict(pca)
#针对princomp()对象的plot方法#
#该方法可以绘制展示每个主成分与其自身方差贡献度相关性的悬崖碎石图。
png("lec12_bar-stone_plot1.png",width=600*3,height=3*300,res=72*3)
par(mfrow=c(1,2),las=2)
#条形图
plot(pca)
abline(h=1,type="2",col="red")
#主成分的碎石图
screeplot(pca, type="lines")
abline(h=1,type="2",col="red")
dev.off()
#=》主成分分布更为离散=》把30个样本区分的更好
#得分图（Score plot）
png("lec12_15scores_scores_plot6.png",width=600*3,height=3*400,res=72*3)
par(mfrow=c(2,3))
#主成分分析之后的前两个主成分得分绘图
plot(pca$scores[,1], pca$scores[,2],type="n")
text(pca$scores[,1],pca$scores[,2],labels=rownames(pca$scores),cex=0.8)
plot(pca$scores[,1], pca$scores[,3],type="n")
text(pca$scores[,1],pca$scores[,3],labels=rownames(pca$scores),cex=0.8)
plot(pca$scores[,1], pca$scores[,4],type="n")
text(pca$scores[,1],pca$scores[,4],labels=rownames(pca$scores),cex=0.8)
plot(pca$scores[,2], pca$scores[,3],type="n")
text(pca$scores[,2],pca$scores[,3],labels=rownames(pca$scores),cex=0.8)
plot(pca$scores[,2], pca$scores[,4],type="n")
text(pca$scores[,2],pca$scores[,4],labels=rownames(pca$scores),cex=0.8)
plot(pca$scores[,3], pca$scores[,4],type="n")
text(pca$scores[,3],pca$scores[,4],labels=rownames(pca$scores),cex=0.8)
dev.off()
png("lec12_15scores_loadings_plot6.png",width=600*3,height=3*400,res=72*3)
par(mfrow=c(2,3))
#主成分分析之后的前两个主成分得分绘图
plot(pca$loadings[,1], pca$loadings[,2],type="n")
text(pca$loadings[,1],pca$loadings[,2],labels=rownames(pca$loadings),cex=0.8)
plot(pca$loadings[,1], pca$loadings[,3],type="n")
text(pca$loadings[,1],pca$loadings[,3],labels=rownames(pca$loadings),cex=0.8)
plot(pca$loadings[,1], pca$loadings[,4],type="n")
text(pca$loadings[,1],pca$loadings[,4],labels=rownames(pca$loadings),cex=0.8)
plot(pca$loadings[,2], pca$loadings[,3],type="n")
text(pca$loadings[,2],pca$loadings[,3],labels=rownames(pca$loadings),cex=0.8)
plot(pca$loadings[,2], pca$loadings[,4],type="n")
text(pca$loadings[,2],pca$loadings[,4],labels=rownames(pca$loadings),cex=0.8)
plot(pca$loadings[,3], pca$loadings[,4],type="n")
text(pca$loadings[,3],pca$loadings[,4],labels=rownames(pca$loadings),cex=0.8)
dev.off()
#设定工作目录
dir="D:/RFile/实验十一"
setwd(dir)
#加载GEOquery
library(GEOquery)
#加载本地的数据
gds4794 <- getGEO(filename='GDS4794.soft.gz')
#查看数据类型
mode(gds4794)
#查看注释信息
Meta(gds4794)
#查看列注释信息=》用来确定哪些列是肿瘤，哪些列是正常对照
Columns(gds4794)
#1：23是肺癌，24：65是正常组织
data<-Table(gds4794)
colnames(data)
#查看数据表行列数
ncol(data)
#[1] 67
nrow(data)
#[1] 54675
#前面两列是标题列，分别为探针id和基因名称
#3：25列是 lung cancer，26：67列是 normal
#第一列探针IDs定义为data的行标题
rownames(data)<-data[,1]
#设定工作目录
dir="D:/RFile/实验十一"
setwd(dir)
#加载GEOquery
library(GEOquery)
#加载本地的数据
gds4794 <- getGEO(filename='GDS4794.soft.gz')
#查看数据类型
mode(gds4794)
#查看注释信息
Meta(gds4794)
#查看列注释信息=》用来确定哪些列是肿瘤，哪些列是正常对照
Columns(gds4794)
#1：23是肺癌，24：65是正常组织
data<-Table(gds4794)
colnames(data)
#查看数据表行列数
ncol(data)
#[1] 67
nrow(data)
#[1] 54675
#前面两列是标题列，分别为探针id和基因名称
#3：25列是 lung cancer，26：67列是 normal
#第一列探针IDs定义为data的行标题
rownames(data)<-data[,1]
#设定工作目录
dir="D:/RFile/实验十一"
setwd(dir)
#加载GEOquery
library(GEOquery)
#加载本地的数据
gds4794 <- getGEO(filename='GDS4794.soft.gz')
#查看数据类型
mode(gds4794)
#查看注释信息
Meta(gds4794)
#查看列注释信息=》用来确定哪些列是肿瘤，哪些列是正常对照
Columns(gds4794)
#1：23是肺癌，24：65是正常组织
data<-Table(gds4794)
colnames(data)
#查看数据表行列数
ncol(data)
#[1] 67
nrow(data)
#[1] 54675
#前面两列是标题列，分别为探针id和基因名称
#3：25列是 lung cancer，26：67列是 normal
#第一列探针IDs定义为data的行标题
rownames(data)<-data[,1]
#变量初始化，用来存放计算结果中的p.value和fold change值
p=NULL
fold.change=NULL
#R用Sys.time()可以查看当前系统时间
#程序开始时记录：
timestart<-Sys.time()
#基因表达谱遍历
for(i in 1:nrow(data))
{
a <- unlist(data[i,3:25])
b <- unlist(data[i,26:67])
fold.change<-c(fold.change,mean(a,na.rm=TRUE)/mean(b,na.rm=TRUE))
x<-t.test(a,b)
p<-c(p,x$p.value)
}
#程序临结束时记录：
timeend<-Sys.time()
#程序运行时间：
timeend-timestart
#Time difference of 51.29762 secs
#data第一列探针名IDs作为p和fold.change的名称
names(p)<-data[,1]
names(fold.change)<-data[,1]
#设定阈值进行筛选
p_value = 0.05
up = 40 #lung cancer 上调40倍
down = 0.025 #lung cancer 下调1/40倍
#筛选
p2 <- p[p<p_value] #p值筛选
fc.up <- fold.change[fold.change>up] #上调基因
fc.down <- fold.change[fold.change<down] #下调基因
length(p2); length(fc.up); length(fc.down) #查看筛选结果
#交集计算
probes.up<-intersect(names(p2),names(fc.up)) #符合统计学显著性的上调基因
length(probes.up)
probes.down<-intersect(names(p2),names(fc.down)) #符合统计学显著性的下调基因
length(probes.down)
probes<-union(probes.up,probes.down) #合并合统计学显著性的上调和下调基因
#上述过程合并进行
#probes <- intersect(names(p2),union(names(fc.up),names(fc.down)))
length(probes)
subdata<-log(data[probes,3:67]) #从原始基因表达谱数据表中提取筛选出来的基因数据
rownames(subdata)<-probes #设定探针IDs为行标题
nrow(subdata)
#数据标准化，除以方差
subdata2<-scale(t(subdata), center=T, scale=T)
rownames(subdata2)<-rep(1:65) #使用数据编号代替样本名称
#subdata2
png("lec12_gds4794_clustering_boxplot1.png",width=600*3,height=300*3,res=72*3)
par(mfrow=c(1,2),las=2)
boxplot(t(subdata))
boxplot(subdata2)
dev.off()
d<-dist(subdata2, method = "euclidean")
#r语言中使用hclust(d, method = "complete", members=NULL) 来进行层次聚类。
hc<-hclust(d,"single")
png("lec12_gds4794_clustering_tree_plot.png",width=600,height=300)
plot(hc)
dev.off()
#使用rect.hclust(tree, k = NULL, which = NULL, x = NULL, h = NULL,border =2, cluster = NULL)来确定类的个数。 tree就是求出来的对象。k为分类的个数，h为类间距离的阈值。border是画出来的颜色，用来分类的
png("lec12_gds4794_clustering_tree_plot2.png", width=600,height=300)
plot(hc)
rect.hclust(hc,k=2)
dev.off()
result=cutree(hc,k=3) #该函数可以用来提取每个样本的所属类别
result
#使用rect.hclust(tree, k = NULL, which = NULL, x = NULL, h = NULL,border =2, cluster = NULL)来确定类的个数。 tree就是求出来的对象。k为分类的个数，h为类间距离的阈值。border是画出来的颜色，用来分类的
png("lec12_gds4794_clustering_tree_plot2.png", width=600,height=300)
plot(hc)
rect.hclust(hc,k=3)
dev.off()
result=cutree(hc,k=3) #该函数可以用来提取每个样本的所属类别
result
Columns(gds4794)
#使用rect.hclust(tree, k = NULL, which = NULL, x = NULL, h = NULL,border =2, cluster = NULL)来确定类的个数。 tree就是求出来的对象。k为分类的个数，h为类间距离的阈值。border是画出来的颜色，用来分类的
png("lec12_gds4794_clustering_tree_plot2.png", width=600,height=300)
plot(hc)
rect.hclust(hc,k=4)
dev.off()
result=cutree(hc,k=4) #该函数可以用来提取每个样本的所属类别
result
#使用rect.hclust(tree, k = NULL, which = NULL, x = NULL, h = NULL,border =2, cluster = NULL)来确定类的个数。 tree就是求出来的对象。k为分类的个数，h为类间距离的阈值。border是画出来的颜色，用来分类的
png("lec12_gds4794_clustering_tree_plot2.png", width=600,height=300)
plot(hc)
rect.hclust(hc,k=5)
dev.off()
result=cutree(hc,k=5) #该函数可以用来提取每个样本的所属类别
result
p_value = 0.05
up = 40 #lung cancer 上调40倍
down = 1/40 #lung cancer 下调1/40倍
#筛选
p2 <- p[p<p_value] #p值筛选
fc.up <- fold.change[fold.change>up] #上调基因
fc.down <- fold.change[fold.change<down] #下调基因
length(p2); length(fc.up); length(fc.down) #查看筛选结果
probes.up<-intersect(names(p2),names(fc.up)) #符合统计学显著性的上调基因
length(probes.up)
probes.down<-intersect(names(p2),names(fc.down)) #符合统计学显著性的下调基因
length(probes.down)
probes<-union(probes.up,probes.down) #合并合统计学显著性的上调和下调基因
#上述过程合并进行
#probes <- intersect(names(p2),union(names(fc.up),names(fc.down)))
length(probes)
subdata<-log(data[probes,3:67]) #从原始基因表达谱数据表中提取筛选出来的基因数据
rownames(subdata)<-probes #设定探针IDs为行标题
nrow(subdata)
#数据标准化，除以方差
subdata2<-scale(t(subdata), center=T, scale=T)
rownames(subdata2)<-rep(1:65) #使用数据编号代替样本名称
#subdata2
png("lec12_gds4794_clustering_boxplot1.png",width=600*3,height=300*3,res=72*3)
par(mfrow=c(1,2),las=2)
boxplot(t(subdata))
boxplot(subdata2)
dev.off()
d<-dist(subdata2, method = "euclidean")
#r语言中使用hclust(d, method = "complete", members=NULL) 来进行层次聚类。
hc<-hclust(d,"single")
png("lec12_gds4794_clustering_tree_plot.png",width=600,height=300)
plot(hc)
dev.off()
#使用rect.hclust(tree, k = NULL, which = NULL, x = NULL, h = NULL,border =2, cluster = NULL)来确定类的个数。 tree就是求出来的对象。k为分类的个数，h为类间距离的阈值。border是画出来的颜色，用来分类的
png("lec12_gds4794_clustering_tree_plot2.png", width=600,height=300)
plot(hc)
rect.hclust(hc,k=4)
dev.off()
result=cutree(hc,k=4) #该函数可以用来提取每个样本的所属类别
result
dir="D:/RFile/实验十一"
setwd(dir)
file="15生信成绩.txt"
scores<-read.table(file,head=T,sep="\t")
colnames(scores)
ncol(scores)
#[1] 25 =》24门课程
nrow(scores)
#[1] 30
#创建数据框
data<-data.frame(scores[,2:25])
colnames(data)<-paste("x",1:24, sep="")
rownames(data)<-scores[,1]
data #查看数据
library(psych)
corr.test(data)
corr.test(data)
data3<-scale(data, center=T, scale=T)
mc<-cov(data3)
mc
summary(pca)
pca<-princomp(data,cor=T)
summary(pca)
pca[]
Columns(gds4794)
