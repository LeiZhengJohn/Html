x_min=-3; x_max=3
#系数区间
b_min=-8; b_max=8
#则因变量理论区间
y_min=y_max=0
for(j in 0:k){y_min = y_min + b_min*(x_max^j); y_max = y_max + b_max*(x_max^j)}
#自变量波动区间
c_min=-1;c_max=1
#创建存储数据的data.frame，共3列，第一列group序号，第二列自变量x，第三列因变量y
data<-data.frame(matrix(NA,group*n,3))
colnames(data)<-c("group","x","y")
#formula<-data.frame(matrix(NA,group,1)) #存放方程式
#根据设定参数进行数据模拟
for(i in 1:group)
{
set.seed(i+runif(1,0,100))
x<-runif(n,min=x_min,max=x_max)
b<-round(runif(k+1,min=b_min,max=b_max))
c<-runif(n,min=c_min,max=c_max)
x<-x+c
y<-data.frame(matrix(0,n,1))
for(m in 0:k){ y <- y + b[m+1] *(x^m) }
from = (i-1)*n+1; to = n*i
data[from:to,1]=rep(i,n)
data[from:to,2]=x
data[from:to,3]=y
}
#绘制一元多次项模拟散点图+拟合曲线
g1=ggplot(data, aes(x=x, y=y, colour=group)) + geom_point()#以颜色梯度区分
data$group <- as.factor(data$group) #group列定义为因子
g2=ggplot(data, aes(x=x, y=y, colour=group)) + geom_point() #以不同颜色区分
g3= ggplot(data, aes(x=x, y=y, colour=group)) + geom_point() + stat_smooth(method='lm', formula=y~poly(x,k)) #增加拟合曲线
g4= ggplot(data, aes(x=x, y=y, colour=group)) + geom_point() + stat_smooth(method='lm', formula=y~poly(x,k)) + theme(axis.title=element_text(face="bold",size=12), axis.text = element_text(face="bold",color="blue", size=10)) #增加图片修饰
#注意4张图的区别，输出到一张图片上
png(file = "plot_y_x-k_ggplot_5.png")
grid.arrange(g1, g2, g3, g4, ncol=2)
dev.off()
library(rgl)
install.packages("rgl")
install.packages("scatterplot3d")
library(scatterplot3d) #绘制3D图
#模拟方程：y=b5*x1^2 + b4*x1 + b3*x2^2 + b2*x2 + b1*x1x2 + b0
#设定模拟参数
#一共生成1组数据，每组100个数值
group=1; n=100
#自变量x1最大区间
x1_min=-3; x1_max=3
#自变量x2最大区间
x2_min=-5; x2_max=5
#系数区间
b_min=-10; b_max=10
#自变量波动区间
c_min=-1;c_max=1
data<-data.frame(matrix(NA,group*n,4))
colnames(data)<-c("group","x1","x2","y")
#formula<-data.frame(matrix(NA,group,1)) #存放方程式
#根据设定参数进行数据模拟
for(i in 1:group)
{
set.seed(i+runif(1,0,100))
x1<-runif(n,min=x1_min,max=x1_max)
x2<-runif(n,min=x2_min,max=x2_max)
b<-round(runif(6,min=b_min,max=b_max))
c1<-runif(n,min=c_min,max=c_max)
c2<-runif(n,min=c_min,max=c_max)
x1<-x1+c1
x2<-x2+c2
y<-b[6]*x1^2 + b[5]*x1 + b[4]*x2^2 + b[3]*x2 + b[2]*x1*x2 + b[1]
from = (i-1)*n+1; to = n*i
data[from:to,]=c(rep(i,n),x1,x2,y)
}
data$group <- as.factor(data$group) #group列定义为因子
#三维散点图
plot3d <- with(data, scatterplot3d(x1, x2, y, col.axis="blue",col.grid="lightblue",
main="scatterplot3d - 1", color = as.numeric(group), pch = 20, angle =
45,type="h"))
#三维散点+二元二次曲面拟合
library(rgl)
#预测脚本
predictgrid<-function(model,xvar,yvar,zvar,res=16,type=NULL){
xrange<-range(model$model[[xvar]])
yrange<-range(model$model[[yvar]])
newdata<-expand.grid(x=seq(xrange[1],xrange[2],length.out=res),
y=seq(yrange[1],yrange[2],length.out=res))
names(newdata)<-c(xvar,yvar)
newdata[[zvar]]<-predict(model,newdata=newdata,type=type)
newdata
}
#x,y,z转为列表
df2mat<-function(p,xvar=NULL,yvar=NULL,zvar=NULL){
if(is.null(xvar)) xvar<-names(p)[1]
if(is.null(yvar)) yvar<-names(p)[2]
if(is.null(zvar)) zvar<-names(p)[3]
x<-unique(p[[xvar]])
y<-unique(p[[yvar]])
z<-matrix(p[[zvar]],nrow=length(y),ncol=length(x))
m<-list(x,y,z)
names(m)<-c(xvar,yvar,zvar)
m
}
#交错出现两个向量元素
interleave<-function(v1,v2) as.vector(rbind(v1,v2))
#mod<-lm(y~x1+x2+x1:x2,data=data) #拟合二元一次平面
mod<-lm(y~x1+I(x1^2)+x2+I(x2^2),data=data) #拟合二元二次曲面
pred_y<-predict(mod)
mpgrid_df<-predictgrid(mod,'x1','x2','y')
mpgrid_list<-df2mat(mpgrid_df)
plot3d(data$x1,data$x2,data$y,xlab='',ylab='',zlab='',axes=FALSE,size=.5,type='
s',lit=FALSE)
spheres3d(data$x1,data$x2,pred_y,alpha=0.4,type='s',size=0.5,lit=FALSE)
segments3d(interleave(data$x1, data$x1),
interleave(data$x2, data$x2),
interleave(pred_y, pred_y),
alpha=0.4,col='red'
)
#预测曲面
surface3d(mpgrid_list$x1,mpgrid_list$x2,mpgrid_list$y,alpha=.4,front='lines',ba
ck='lines')
#其他设置
rgl.bbox(color='grey50',emission='grey50',xlen=0,ylen=0,zlen=0)
rgl.material(color='black')
axes3d(edges=c('x--','y+-','z--'), cex=.75)
mtext3d('x1',edge='x—',line=2)
mtext3d('x2',edge='y+-',line=3)
mtext3d('y',edge='z—',line=3)
dir="D:/RFile/实验十"
setwd(dir)
#加载GEOquery
library(GEOquery)
#加载本地的数据
gds4794 <- getGEO(filename='GDS4794.soft.gz')
#查看数据类型
mode(gds4794)
#查看注释信息
Meta(gds4794)
#查看列注释信息=》用来确定哪些列是肿瘤，哪些列是正常对照
Columns(gds4794)
#1：23是肺癌，24：65是正常组织
data<-Table(gds4794)
#查看数据表的列名
colnames(data)
#查看数据表行列数
ncol(data)
#[1] 67
nrow(data)
#[1] 54675
#前面两列是标题列，分别为探针id和基因名称
#3：25列是 lung cancer，26：67列是 normal
#第一列探针IDs定义为data的行标题
rownames(data)<-data[,1]
#随机抽取至少10行数据
n=10
#使用以下代码进行循环测试：齐方差、F检验，p>0.1；齐方差、F检验，双因素p<0.1，无交互作用；齐方差、F检验，双因素p无要求，p<0.1
#按行随机抽样【实验结果中需要记录】
row.names<-rownames(data)
sam.row.name <- sample(row.names,n,replace=F)
sam.row.name #查看抽中的数据行探针id
subdata<-data[sam.row.name,3:67] #提取抽样数据
#加上样本病理类型数据共n+1列
#初始化数据表
data2<-data.frame(matrix(NA,65, n+1))
#增加样本病理类型分类数据，肺癌=1，其他正常=0
data2[,1]<-c(rep(1,23),rep(0,42))
data2[,2:(n+1)]<-t(log(subdata)) #后面n列存放筛选出来的基因数据，注意矩阵行列转换
colnames(data2)<-c("y",paste("x",1:n,sep="")) #设定列标题y,x1,x2,...,x10
#以样本类型为因变量y，其他所有基因表达式水平为自变量x1,x2,...x10，进行总体回归分析
glm0<-glm(y~.,family=binomial(link='logit'),data=data2)
summary(glm0)
#向后逐步回归法
glm.step<-step(glm0,direction="backward")
summary(glm.step)
#绘制回归评估的4张图
png(file = "glm4.png")
par(mfrow=c(2,2))
plot(glm.step)
dev.off()
#car包里的influencePlot()函数能一次性同时检查离群点、高杠杆点、强影响点
library(car)
png("influencePlot.png")
influencePlot(glm.step,id.method = "identity", main="Influence Plot",sub="Circle size is proportional to Cook's distance")
dev.off()
#绘制subdata的热图
colnames(subdata)<-Columns(gds4794)$disease.state
png(file = "heatmap1.png")
heatmap(as.matrix(log(subdata)), Rowv = NA, Colv = NA)
dev.off()
#随机抽取至少10行数据
n=10
#使用以下代码进行循环测试：齐方差、F检验，p>0.1；齐方差、F检验，双因素p<0.1，无交互作用；齐方差、F检验，双因素p无要求，p<0.1
#按行随机抽样【实验结果中需要记录】
row.names<-rownames(data)
sam.row.name <- sample(row.names,n,replace=F)
sam.row.name #查看抽中的数据行探针id
subdata<-data[sam.row.name,3:67] #提取抽样数据
#加上样本病理类型数据共n+1列
#初始化数据表
data2<-data.frame(matrix(NA,65, n+1))
#增加样本病理类型分类数据，肺癌=1，其他正常=0
data2[,1]<-c(rep(1,23),rep(0,42))
data2[,2:(n+1)]<-t(log(subdata)) #后面n列存放筛选出来的基因数据，注意矩阵行列转换
colnames(data2)<-c("y",paste("x",1:n,sep="")) #设定列标题y,x1,x2,...,x10
#以样本类型为因变量y，其他所有基因表达式水平为自变量x1,x2,...x10，进行总体回归分析
glm0<-glm(y~.,family=binomial(link='logit'),data=data2)
summary(glm0)
#向后逐步回归法
glm.step<-step(glm0,direction="backward")
summary(glm.step)
#绘制回归评估的4张图
png(file = "glm4.png")
par(mfrow=c(2,2))
plot(glm.step)
dev.off()
#car包里的influencePlot()函数能一次性同时检查离群点、高杠杆点、强影响点
library(car)
png("influencePlot.png")
influencePlot(glm.step,id.method = "identity", main="Influence Plot",sub="Circle size is proportional to Cook's distance")
dev.off()
#绘制subdata的热图
colnames(subdata)<-Columns(gds4794)$disease.state
png(file = "heatmap1.png")
heatmap(as.matrix(log(subdata)), Rowv = NA, Colv = NA)
dev.off()
#随机抽取至少10行数据
n=10
#使用以下代码进行循环测试：齐方差、F检验，p>0.1；齐方差、F检验，双因素p<0.1，无交互作用；齐方差、F检验，双因素p无要求，p<0.1
#按行随机抽样【实验结果中需要记录】
row.names<-rownames(data)
sam.row.name <- sample(row.names,n,replace=F)
sam.row.name #查看抽中的数据行探针id
subdata<-data[sam.row.name,3:67] #提取抽样数据
#加上样本病理类型数据共n+1列
#初始化数据表
data2<-data.frame(matrix(NA,65, n+1))
#增加样本病理类型分类数据，肺癌=1，其他正常=0
data2[,1]<-c(rep(1,23),rep(0,42))
data2[,2:(n+1)]<-t(log(subdata)) #后面n列存放筛选出来的基因数据，注意矩阵行列转换
colnames(data2)<-c("y",paste("x",1:n,sep="")) #设定列标题y,x1,x2,...,x10
#以样本类型为因变量y，其他所有基因表达式水平为自变量x1,x2,...x10，进行总体回归分析
glm0<-glm(y~.,family=binomial(link='logit'),data=data2)
summary(glm0)
#向后逐步回归法
glm.step<-step(glm0,direction="backward")
summary(glm.step)
#绘制回归评估的4张图
png(file = "glm4.png")
par(mfrow=c(2,2))
plot(glm.step)
dev.off()
#car包里的influencePlot()函数能一次性同时检查离群点、高杠杆点、强影响点
library(car)
png("influencePlot.png")
influencePlot(glm.step,id.method = "identity", main="Influence Plot",sub="Circle size is proportional to Cook's distance")
dev.off()
#绘制subdata的热图
colnames(subdata)<-Columns(gds4794)$disease.state
png(file = "heatmap1.png")
heatmap(as.matrix(log(subdata)), Rowv = NA, Colv = NA)
dev.off()
#随机抽取至少10行数据
n=10
#使用以下代码进行循环测试：齐方差、F检验，p>0.1；齐方差、F检验，双因素p<0.1，无交互作用；齐方差、F检验，双因素p无要求，p<0.1
#按行随机抽样【实验结果中需要记录】
row.names<-rownames(data)
sam.row.name <- sample(row.names,n,replace=F)
sam.row.name #查看抽中的数据行探针id
subdata<-data[sam.row.name,3:67] #提取抽样数据
#加上样本病理类型数据共n+1列
#初始化数据表
data2<-data.frame(matrix(NA,65, n+1))
#增加样本病理类型分类数据，肺癌=1，其他正常=0
data2[,1]<-c(rep(1,23),rep(0,42))
data2[,2:(n+1)]<-t(log(subdata)) #后面n列存放筛选出来的基因数据，注意矩阵行列转换
colnames(data2)<-c("y",paste("x",1:n,sep="")) #设定列标题y,x1,x2,...,x10
#以样本类型为因变量y，其他所有基因表达式水平为自变量x1,x2,...x10，进行总体回归分析
glm0<-glm(y~.,family=binomial(link='logit'),data=data2)
summary(glm0)
#向后逐步回归法
glm.step<-step(glm0,direction="backward")
summary(glm.step)
#绘制回归评估的4张图
png(file = "glm4.png")
par(mfrow=c(2,2))
plot(glm.step)
dev.off()
#car包里的influencePlot()函数能一次性同时检查离群点、高杠杆点、强影响点
library(car)
png("influencePlot.png")
influencePlot(glm.step,id.method = "identity", main="Influence Plot",sub="Circle size is proportional to Cook's distance")
dev.off()
#绘制subdata的热图
colnames(subdata)<-Columns(gds4794)$disease.state
png(file = "heatmap1.png")
heatmap(as.matrix(log(subdata)), Rowv = NA, Colv = NA)
dev.off()
#变量初始化，用来存放计算结果中的p.value和fold change值
p=NULL
fold.change=NULL
#R用Sys.time()可以查看当前系统时间
#程序开始时记录：
timestart<-Sys.time()
#基因表达谱遍历
for(i in 1:nrow(data))
{
a <- unlist(data[i,3:25])
b <- unlist(data[i,26:67])
fold.change<-c(fold.change,mean(a,na.rm=TRUE)/mean(b,na.rm=TRUE))
x<-t.test(a,b)
p<-c(p,x$p.value)
}
#程序临结束时记录：
timeend<-Sys.time()
#程序运行时间：
timeend-timestart
#Time difference of 51.29762 secs
#data第一列探针名IDs作为p和fold.change的名称
names(p)<-data[,1]
names(fold.change)<-data[,1]
#设定阈值进行筛选
p_value = 0.01
up = 50 #lung cancer 上调2倍
down = 0.02 #lung cancer 下调2倍
#筛选
p2 <- p[p<p_value] #p值筛选
fc.up <- fold.change[fold.change>up] #上调基因
fc.down <- fold.change[fold.change<down] #下调基因
length(p2); length(fc.up); length(fc.down) #查看筛选结果
#交集计算
probes.up<-intersect(names(p2),names(fc.up)) #符合统计学显著性的上调基因
length(probes.up)
probes.down<-intersect(names(p2),names(fc.down)) #符合统计学显著性的下调基因
length(probes.down)
probes<-union(probes.up,probes.down) #合并合统计学显著性的上调和下调基因
#上述过程合并进行
#probes <- intersect(names(p2),union(names(fc.up),names(fc.down)))
length(probes)
subdata2<-data[probes,3:67] #从原始基因表达谱数据表中提取筛选出来的基因数据
rownames(subdata2)<-probes #设定探针IDs为行标题
nrow(subdata2)
#如果筛选的基因数量过多，接下来则无法进行下去
#加上样本病理类型数据共17列
data3<-data.frame(matrix(NA,65, 17)) #初始化数据表
data3[,1]<-c(rep(1,23),rep(0,42)) #增加样本病理类型分类数据，肺癌=1，其他正常=0
data3[,2:17]<-t(log(subdata2)) #后面16列存放筛选出来的基因数据，注意矩阵行列转换
colnames(data3)<-c("y",paste("x",1:16,sep="")) #设定列标题
#以样本类型为因变量y，其他所有基因表达式水平为自变量x1,x2,...，进行总体回归分析
glm0<-glm(y~.,family=binomial(link='logit'),data=data3)
summary(glm0)
glm.step<-step(glm0,direction="backward")
summary(glm.step)
png(file = "lec11_ICU_glm.png")
par(mfrow=c(2,2))
plot(glm.step)
dev.off()
#car包里的influencePlot()函数能一次性同时检查离群点、高杠杆点、强影响点。
library(car)
png("influencePlot.png")
influencePlot(glm.step,id.method = "identity", main="Influence Plot",sub="Circle size is proportional to Cook's distance")
dev.off()
#绘制subdata2的热图
colnames(subdata2)<-Columns(gds4794)$disease.state
png(file = "heatmap.png")
heatmap(as.matrix(log(subdata2)), Rowv = NA, Colv = NA)
dev.off()
data2<-data.frame(matrix(NA,65, n+1))
#增加样本病理类型分类数据，肺癌=1，其他正常=0
data2[,1]<-c(rep(1,23),rep(0,42))
data2[,2:(n+1)]<-t(log(subdata)) #后面n列存放筛选出来的基因数据，注意矩阵行列转换
colnames(data2)<-c("y",paste("x",1:n,sep="")) #设定列标题y,x1,x2,...,x10
#以样本类型为因变量y，其他所有基因表达式水平为自变量x1,x2,...x10，进行总体回归分析
glm0<-glm(y~.,family=binomial(link='logit'),data=data2)
summary(glm0)
#向后逐步回归法
glm.step<-step(glm0,direction="backward")
summary(glm.step)
#绘制回归评估的4张图
png(file = "glm4.png")
par(mfrow=c(2,2))
plot(glm.step)
dev.off()
#car包里的influencePlot()函数能一次性同时检查离群点、高杠杆点、强影响点
library(car)
png("influencePlot.png")
influencePlot(glm.step,id.method = "identity", main="Influence Plot",sub="Circle size is proportional to Cook's distance")
dev.off()
#绘制subdata的热图
colnames(subdata)<-Columns(gds4794)$disease.state
png(file = "heatmap1.png")
heatmap(as.matrix(log(subdata)), Rowv = NA, Colv = NA)
dev.off()
dir="D:/RFile/实验十"
setwd(dir)
file="US_Temperatures_Data.txt"
data<-read.table(file,head=T,sep="\t")
colnames(data)
a<-max(data$JanTemp) - min(data$JanTemp) + 1 #设定颜色梯度区间
png(file = "plot_y_x_t_scatter.png")
cPal <- colorRampPalette(c('green','red'))
Cols <- cPal(a)[as.numeric(cut(data$JanTemp,breaks = a))]
plot(data$Long,data$Lat,pch = 20,col = Cols,cex=2)
dev.off()file="US_Temperatures_Data"
data<-read.table(file,head=T,sep="\t")
colnames(data)
a<-max(data$JanTemp) - min(data$JanTemp) + 1 #设定颜色梯度区间
png(file = "plot_y_x_t_scatter.png")
cPal <- colorRampPalette(c('green','red'))
Cols <- cPal(a)[as.numeric(cut(data$JanTemp,breaks = a))]
plot(data$Long,data$Lat,pch = 20,col = Cols,cex=2)
dev.off()
dir="D:/RFile/实验十"
setwd(dir)
file="US_Temperatures_Data"
data<-read.table(file,head=T,sep="\t")
colnames(data)
a<-max(data$JanTemp) - min(data$JanTemp) + 1 #设定颜色梯度区间
png(file = "plot_y_x_t_scatter.png")
cPal <- colorRampPalette(c('green','red'))
Cols <- cPal(a)[as.numeric(cut(data$JanTemp,breaks = a))]
plot(data$Long,data$Lat,pch = 20,col = Cols,cex=2)
dev.off()
dir="D:/RFile/实验十"
setwd(dir)
file="US_Temperatures_Data.txt"
data<-read.table(file,head=T,sep="\t")
colnames(data)
a<-max(data$JanTemp) - min(data$JanTemp) + 1 #设定颜色梯度区间
png(file = "plot_y_x_t_scatter.png")
cPal <- colorRampPalette(c('green','red'))
Cols <- cPal(a)[as.numeric(cut(data$JanTemp,breaks = a))]
plot(data$Long,data$Lat,pch = 20,col = Cols,cex=2)
dev.off()
model1=loess(JanTemp~Lat,data=data,span=0.4)
summary(model1)
png(file = "plot_T_Lat_loess.png")
plot(data$JanTemp~data$Lat,pch = 20,col = Cols,cex=2)
lines(data$Lat,model1$fit,col='red',lty=2,lwd=2)
dev.off()
#JanTemp~Long拟合
model2=loess(JanTemp~Long,data=data,span=0.8)
summary(model2)
png(file = "plot_T_Long_loess.png")
plot(data$JanTemp~data$Long,pch = 20,col = Cols,cex=2)
lines(data$Long,model2$fit,col='red',lty=2,lwd=2)
dev.off()
#二元线性回归的探索
lm.line<-lm(JanTemp~Lat+Long,data=data)
summary(lm.line)
png(file = "plot_y_x_t_lm.png")
par(mfrow=c(2,2))
plot(lm.line)
dev.off()
#Lat为线性，Long为三次项
model <- lm(JanTemp ~ Lat + poly(Long,3),data=data)
summary(model)
#模型参数的置信区间
confint(model, level=0.95)
#拟合VS残差图,如果这是一个拟合效果比较不错的模型，应该看不到任何一种模型的特征
png(file = "plot_T_Lat_Long_model_residuals.png")
par(mfrow=c(2,2))
plot(model)
plot(fitted(model),residuals(model))
dev.off()
#Lat为线性，Long为三次项
model <- lm(JanTemp ~ Lat + poly(Long,3),data=data)
summary(model)
#模型参数的置信区间
confint(model, level=0.95)
#拟合VS残差图,如果这是一个拟合效果比较不错的模型，应该看不到任何一种模型的特征
png(file = "plot_T_Lat_Long_model_residuals.png")
par(mfrow=c(2,2))
plot(model)
plot(fitted(model),residuals(model))
dev.off()
#Lat为线性，Long为三次项
model <- lm(JanTemp ~ Lat + poly(Long,3),data=data)
summary(model)
#模型参数的置信区间
confint(model, level=0.95)
#拟合VS残差图,如果这是一个拟合效果比较不错的模型，应该看不到任何一种模型的特征
png(file = "plot_T_Lat_Long_model_residuals.png")
plot(model)
#plot(fitted(model),residuals(model))
dev.off()
#Lat为线性，Long为三次项
model <- lm(JanTemp ~ Lat + poly(Long,3),data=data)
summary(model)
#模型参数的置信区间
confint(model, level=0.95)
#拟合VS残差图,如果这是一个拟合效果比较不错的模型，应该看不到任何一种模型的特征
png(file = "plot_T_Lat_Long_model_residuals.png")
plot(model)
#plot(fitted(model),residuals(model))
dev.off()
model <- lm(JanTemp ~ Lat + poly(Long,3),data=data)
summary(model)
#模型参数的置信区间
confint(model, level=0.95)
#拟合VS残差图,如果这是一个拟合效果比较不错的模型，应该看不到任何一种模型的特征
png(file = "plot_T_Lat_Long_model_residuals.png")
par(mfrow=c(2,2))
plot(model)
#plot(fitted(model),residuals(model))
dev.off()
model <- lm(JanTemp ~ Lat + poly(Long,3),data=data)
summary(model)
#模型参数的置信区间
confint(model, level=0.95)
#拟合VS残差图,如果这是一个拟合效果比较不错的模型，应该看不到任何一种模型的特征
png(file = "plot_T_Lat_Long_model_residuals.png")
#par(mfrow=c(2,2))
#plot(model)
plot(fitted(model),residuals(model))
dev.off()
